---
title: "Federation: Distributed AI Agents"
date: 2026-01-12
author: AnyCowork Team
---

# Federation: Distributed AI Agents

**January 12, 2026** Â· 10 min read

Learn how AnyCowork's federation system, inspired by ROS2, enables you to build distributed AI agent networks that scale.

## What is Federation?

Federation in AnyCowork allows multiple instances to work together as a unified system. Think of it as a network of AI agents that can:

- Share information in real-time
- Distribute workloads
- Coordinate actions
- Scale horizontally

## Inspired by ROS2

We drew inspiration from ROS2 (Robot Operating System 2), which has proven patterns for distributed systems:

### Topics (Pub/Sub)

Publish and subscribe to event streams:

```python
from anycowork.federation import Node

node = Node(name="desktop")

# Publish to a topic
pub = node.create_publisher("agent-updates")
await pub({"agent_id": "agent-1", "status": "active"})

# Subscribe to a topic
def handle_update(data):
    print(f"Agent update: {data}")

node.create_subscriber("agent-updates", handle_update)
```

### Services (RPC)

Request-response patterns:

```python
# Provide a service
async def get_agent_status(params):
    return {"status": "active", "uptime": 3600}

node.register_service("get-agent-status", get_agent_status)

# Call a service
response = await node.call_service("get-agent-status", {"agent_id": "agent-1"})
```

### Actions (Long-running Tasks)

For tasks that take time:

```python
# Register an action
async def process_document(goal, feedback_cb, cancel_event):
    for i in range(100):
        if cancel_event.is_set():
            return {"cancelled": True}
        feedback_cb({"progress": i})
        await asyncio.sleep(0.1)
    return {"success": True}

node.register_action("process-document", process_document)

# Execute an action
result = await node.execute_action(
    "process-document",
    {"doc_id": "123"},
    feedback_callback=lambda fb: print(f"Progress: {fb['progress']}%")
)
```

## Use Cases

### 1. Desktop + Mobile Sync

Keep your conversations in sync across devices:

```python
# Desktop node
desktop = Node(name="desktop")
desktop.create_publisher("messages")

# Mobile node
mobile = Node(name="mobile")
mobile.create_subscriber("messages", sync_to_local)

# Messages automatically sync
```

### 2. Distributed Processing

Offload heavy tasks to powerful machines:

```python
# Laptop (lightweight)
laptop = Node(name="laptop")
result = await laptop.call_service("analyze-video", {"url": "..."})

# Server (powerful)
server = Node(name="server")
server.register_service("analyze-video", heavy_analysis)
```

### 3. Multi-Agent Collaboration

Agents working together:

```python
# Research agent
research = Node(name="research")
research.create_publisher("findings")

# Writing agent
writer = Node(name="writer")
writer.create_subscriber("findings", incorporate_research)

# Editor agent
editor = Node(name="editor")
editor.create_subscriber("drafts", review_and_edit)
```

## Network Architecture

### Discovery

Nodes can discover each other automatically:

```python
node = Node(
    name="my-node",
    discovery_enabled=True
)

# Automatically finds other nodes on the network
```

### Security

Secure your federation:

```python
node = Node(
    name="my-node",
    auth_token="secret-token",
    tls_enabled=True
)
```

### Load Balancing

Distribute requests across nodes:

```python
# Round-robin across available nodes
node.call_service(
    "process-task",
    params,
    strategy="round-robin"
)
```

## Best Practices

### 1. Design for Failure

Nodes can go offline. Handle it gracefully:

```python
try:
    result = await node.call_service("remote-service", params)
except ServiceUnavailable:
    # Fallback to local processing
    result = local_process(params)
```

### 2. Use Topics for Events

For fire-and-forget notifications:

```python
# Good: Topic for events
node.create_publisher("user-logged-in")

# Bad: Service for events (blocks)
node.register_service("notify-login", ...)
```

### 3. Use Services for Queries

For request-response:

```python
# Good: Service for queries
result = await node.call_service("get-user", {"id": 123})

# Bad: Topic for queries (no response)
node.create_publisher("get-user-request")
```

### 4. Use Actions for Long Tasks

For tasks that take time:

```python
# Good: Action with progress
result = await node.execute_action(
    "train-model",
    params,
    feedback_callback=show_progress
)

# Bad: Service (blocks, no progress)
result = await node.call_service("train-model", params)
```

## Performance

### Benchmarks

On a local network:

- **Topic latency**: < 1ms
- **Service latency**: < 5ms
- **Action overhead**: < 10ms

### Optimization Tips

1. **Batch messages** when possible
2. **Use compression** for large payloads
3. **Cache service responses** when appropriate
4. **Monitor network health**

## Real-World Example

Here's a complete example of a federated system:

```python
from anycowork.federation import Node
import asyncio

# Node 1: Data collector
collector = Node(name="collector")
pub = collector.create_publisher("raw-data")

async def collect_data():
    while True:
        data = await fetch_data()
        await pub(data)
        await asyncio.sleep(1)

# Node 2: Processor
processor = Node(name="processor")

async def process_data(data):
    result = analyze(data)
    await results_pub(result)

processor.create_subscriber("raw-data", process_data)
results_pub = processor.create_publisher("results")

# Node 3: Dashboard
dashboard = Node(name="dashboard")

def update_ui(result):
    display(result)

dashboard.create_subscriber("results", update_ui)

# Run all nodes
await asyncio.gather(
    collector.run(),
    processor.run(),
    dashboard.run()
)
```

## Future Enhancements

We're working on:

- **Service mesh integration** - Istio/Linkerd support
- **Auto-scaling** - Spawn nodes based on load
- **Global federation** - Connect across the internet
- **Monitoring dashboard** - Visualize your federation

## Get Started

Try federation today:

```bash
pip install anycowork
```

Create two nodes:

```python
# Terminal 1
node1 = Node(name="node1")
pub = node1.create_publisher("test")
await pub({"message": "Hello from node1"})

# Terminal 2
node2 = Node(name="node2")
node2.create_subscriber("test", print)
```

## Conclusion

Federation unlocks powerful distributed AI architectures:

- **Scalability** - Add nodes as needed
- **Resilience** - Survive node failures
- **Flexibility** - Mix and match capabilities
- **Performance** - Distribute workloads

Start building distributed AI systems with AnyCowork today!

---

*Questions? Join our [Discord](https://discord.gg/anycowork) or [open an issue](https://github.com/anycowork/anycowork/issues).*
